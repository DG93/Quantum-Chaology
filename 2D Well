# -*- coding: utf-8 -*-
"""
Created on Wed Sep 30 17:35:32 2015

@author: DNSG
"""

import numpy as np
from numpy import matrix
from numpy import linalg
import math
from math import sqrt,sin,pi
import matplotlib.pyplot as plt
import scipy.constants as sc
from mpl_toolkits.mplot3d import Axes3D
from matplotlib import cm
from matplotlib.mlab import griddata

""" 
2D well labelled in following pattern:
  _____
 |4 5 6|
 |1 2 3|
 |_____|
"""
c = int(input("Enter number of points in x axis: "))
r = int(input("Enter number points in y axis: "))
x = float(input("Enter width (x axis) of well: "))
y = float(input("Enter depth (y axis) of well: "))
state_x = int(input("Enter energy state in x (GS=1): "))
state_y = int(input("Enter energy state in y (GS=1): "))
n = r*c
#state_x = state_x-1
#state_y = state_y-1
a = y/r # spacing in y axis
b = x/c # spacing in x axis

H = np.zeros((n,n))
i,j = np.indices(H.shape)
H[i==j] = 4.
H[i==j-1] = -1.
H[i==j+1] = -1.

larger = 1
smaller = 1
if r > c:
    larger = r
    smaller = c
elif r == c:
    larger = r
    smaller = r
else:
    larger = c
    smaller = r

H[i==j+larger] = -1
H[i==j-larger] = -1
for k in range(1,smaller):
    ks = k*larger
    if(ks)<=n:
        H[ks-1,ks] = 0
        H[ks,ks-1] = 0
 
print(H)

"""
# Include zeros
G = np.zeros((n+2*c,n))
j=1
for i in range (1,n+1):
    G[j,:] = H[i-1,:]
    if i%c == 0:
        j=j+3
        
    else:
        j=j+1
j=0
for i in range(0,n):
    if i%c == 0:
        G = np.insert(G,j,0, axis=1)
        G = np.insert(G,j+1,0, axis=1)
        j = j+c+2
G = np.delete(G,0,axis=1)
G = np.insert(G,n+2*c-1,0,axis=1)
for i in range(0,c+2):
    G = np.insert(G,n+2*c+i,0,axis=1)
    G = np.insert(G,0,0,axis=1)
for i in range(0,c+2):
    G = np.insert(G,n+2*c+i,0,axis=0)
    G = np.insert(G,0,0,axis=0)
    
print(G)
"""



w, v = linalg.eig(H)
#print(w,v)

s=[]
if state_x > state_y:
    high_state = state_x
    counter = 1
else:
    high_state = state_y
    counter = 0

for i in range(1,(1+high_state**2)):
    for j in range(1,(1+high_state**2)):
        if ((i**2)+(j**2)) < ((state_x**2)+(state_y**2)):
            s.append((i**2)+(j**2))


#print(s)

# enumerate list and sort by eigenvalues
# return index of relevant energy level
state_ind = sorted(enumerate(w), key=lambda x: x[1])[len(s)+counter][0]


#print("Eigenvalues:")
#print(w)
#print("Eigenvectors:")
#print(v[:,state_ind])

xt = []
for i in range(0, c+2):
    xt.append((x*i)/(c+1))
    #print('xt[{}] = {}'.format(i, xt[i]))

yt = []
for i in range(0, r+2):
    yt.append((y*i)/(r+1))
    #print('yt[{}] = {}'.format(i, yt[i]))

x_v = [0]
for i in range(0,c):
    x_v.append(v[i,state_ind])
x_v.append(0)
y_v = [0]
for i in range(0, n-1, c):
    y_v.append(v[i, state_ind])
y_v.append(0)
#for i in range(0,r+2):   
    #print('y_v[{}] = {}'.format(i, y_v[i]))
#for i in range(0,c+2):
    #print('x_v[{}] = {}'.format(i, x_v[i]))

# 2D PLOT
"""
plt.plot(xt, x_v, label='x axis')
plt.plot(yt, y_v, label='y axis')

plt.legend()
plt.show()
"""

# 3D PLOT
X, Y = np.meshgrid(xt, yt)
#print(X)
#print(Y)
# Reshape the eigenvector
z = v[:,state_ind].reshape((r,c))

z = np.insert(z,0,0, axis=1)
z = np.insert(z,c+1,0, axis=1)
z = np.insert(z, 0,0,axis=0)
zero = np.zeros((1,c+2))
z = np.append(z,zero, axis=0 )
#print(z)


# Analytical solution (normalised)
ansatz = max(v[:,state_ind])*np.sin((state_x)*pi*X/x)*np.sin((state_y)*pi*Y/y)

fig = plt.figure(figsize=(10,8))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(X,Y,z, cmap=cm.coolwarm, cstride=1, rstride=1)
ans = ax.plot_wireframe(X,Y,ansatz, cstride=1, rstride=1)
#ax.set_zlim(-1.0, 2.0)
fig.colorbar(surf)
plt.show()
fig.savefig('2Dwell.png')
