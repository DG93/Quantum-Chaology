# -*- coding: utf-8 -*-

import numpy as np
from numpy import matrix
from numpy import linalg
import math
from math import sqrt,sin,pi
import matplotlib.pyplot as plt
import scipy.integrate
import oneDQCfunctions as qcf

        
n =71#int(input("Enter number of steps: "))
l = 1#float(input("Enter width of well: "))
state = 43#int(input("Enter energy state (GS=1): "))
state = state-1
a = l/n
sigma_psi = a**2
H = qcf.genMatrix(n)
# Ansatz probability wavefunction
xt = np.linspace(0,l,n+2)
ansatz = (sqrt((2/l))*np.sin(((state+1)*np.pi*xt)/l))**2
# Ansatz energy
k = ((state+1)*np.pi)/l
ans_energy = ( (k**2)/ (2) )*a**2


##################### NOT USING SYMMETRIES #####################

w, v = linalg.eig(H)

# enumerate list and sort by eigenvalues
# return index of relevant energy level
state_ind = sorted(enumerate(w), key=lambda x: x[1])[state][0]

# Wavefunction
c = qcf.genWvf(v,n,state_ind)

# Normalised Probability
C = qcf.genProb(c, l, n)
    
# Discrete Prob. Error
sigma_p = qcf.probError(c, sigma_psi)

# Calculate energy from eigenvalue
energy = (( (w[state_ind])/ (2) ))

# Plot
qcf.plotProb(l,n,C,state,sigma_p,ansatz, energy, ans_energy, a)

#difference plot
qcf.plotDiff(l,n,C,ansatz,state)


# Discrete energy errors
sigma_l = qcf.discEnError(n,sigma_psi,v,w)


# Both energies plot
qcf.plotEvN(n,w,l,a)

# Difference in energies plot
qcf.plotEdiff(n, w,l,a)

# Print energies
nt = np.linspace(1,n,n)
E = sorted(w/2)
tot_ans_energy = ( ((((nt)*np.pi)/l)**2)/ (2) )*a**2
E_diff = np.absolute(E - tot_ans_energy)
print('Energy state = %s' % str(state+1))
print('Discrete energy = %s' % (energy))
print('Energy difference = %s' % E_diff[state])


##################### USING SYMMETRIES #####################

oe = qcf.OE(state)
N = int((n+1)/2)
M=N-1
#print(N)
sH = np.zeros((N,N))
for j in range(0,N):
    for i in range(0,N):
        sH[i,j] = (H[M+i,M+j]+oe*H[M-i,M+j]+oe*H[M+i,M-j]+H[M-i,M-j])/(sqrt(1+qcf.delta(j,0))*sqrt(1+qcf.delta(i,0)))

sw, sv = linalg.eig(sH)
s_state = int((state+1)/2)
s_state_ind = sorted(enumerate(sw), key=lambda x: x[1])[s_state][0]
sE = (( (sw[s_state_ind])/ (4) ))

# Wavefunction
sc = qcf.genWvf(sv,N,s_state_ind)
sc.pop(0)
rev = sc[:]
rev.reverse()

ssc=[0]*(2*len(sc)-1)
L = int(len(ssc)/2)
for i in range(0,L+1):
        ssc[i] = ssc[i] + rev[i]
        ssc[i+int(len(ssc)/2)] = ssc[i+int(len(ssc)/2)] + sc[i]
ssc[L] = ssc[L]/sqrt(2)

# Normalised Probability
sC = qcf.genProb(ssc, l, n)

s_sigma_p = qcf.probError(ssc, sigma_psi)
s_xt = np.linspace(0,l,n+2)
s_ansatz = (sqrt((2/l))*np.sin(((state+1)*np.pi*s_xt)/l))**2
qcf.plotProb(l,n,sC,state,s_sigma_p,s_ansatz, sE, ans_energy, a)

# Print energies
nt = np.linspace(1,n,N)

E = sorted(sw/4)
tot_ans_energy = ( ((((nt)*np.pi)/l)**2)/ (2) )*a**2
E_diff = np.absolute(E - tot_ans_energy)
print('Energy state = %s' % str(state+1))
print('Discrete energy = %s' % (sE))
print('Energy difference = %s' % E_diff[s_state])
