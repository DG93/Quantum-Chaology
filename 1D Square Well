# -*- coding: utf-8 -*-

import numpy as np
from numpy import matrix
from numpy import linalg
import math
from math import sqrt,sin,pi
import matplotlib.pyplot as plt
import scipy.constants as sc
import scipy.integrate
import oneDQCfunctions as qcf

        
n = 5#int(input("Enter number of steps: "))
l = 1#float(input("Enter width of well: "))
state_t = 1#int(input("Enter energy state (GS=1): "))

a = l/n

H = qcf.genMatrix(n)
#print(H)

w, v = linalg.eig(H)

#myList = [1, 2, 3, 100, 5]
state = state_t-1

# enumerate list and sort by eigenvalues
# return index of relevant energy level
state_ind = sorted(enumerate(w), key=lambda x: x[1])[state][0]

# Wavefunction
c = qcf.genWvf(v,n,state_ind)

# Normalised Probability
C = qcf.genProb(c, l, n)
    
# Discrete Prob. Error
sigma_psi = a**2
sigma_p = qcf.probError(c, sigma_psi)


# Ansatz probability wavefunction
xt = np.linspace(0,l,n+2)
ansatz = (sqrt((2/l))*np.sin(((state+1)*np.pi*xt)/l))**2

# calculate energy from eigenvalue
energy = (( (w[state_ind])/ (2) ))
k = ((state+1)*np.pi)/l
ans_energy = ( (k**2)/ (2) )*a**2

# Plot
qcf.plotProb(l,n,C,state,sigma_p,ansatz, energy, ans_energy, a)

#difference plot
qcf.plotDiff(l,n,C,ansatz,state)

"""
# Discrete energy errors
h = np.zeros((n,n))
i,j = np.indices(h.shape)
h[i,j] = sigma_psi
delta_l = np.dot(np.dot(linalg.inv(v),h),v)
#print(delta_l)
i,j = np.indices(delta_l.shape)
sigma_l = delta_l[i==j]
#print(sigma_l)
sigma_l = [x for (y,x) in sorted(zip(w,sigma_l))]
"""

# Both energies plot
qcf.plotEvN(n,w,l,a)

# Difference in energies plot
qcf.plotEdiff(n, w,l,a)

# Print energies
nt = np.linspace(1,n,n)
E = sorted(w/2)
tot_ans_energy = ( ((((nt)*np.pi)/l)**2)/ (2) )*a**2
E_diff = np.absolute(E - tot_ans_energy)
print('Energy state = %s' % str(state+1))
print('Discrete energy = %s' % (energy))
print('Energy difference = %s' % E_diff[state])


# Symmerties
N = int((n-1)/2)
print(N)
#Nt = np.linspace(-N,N,n+1)
eH = np.zeros((N+1,N+1))
for j in range(0,N+1):
    for i in range(0,N+1):
        eH[i,j] = (H[i,j]+H[-i,j]+H[i,-j]+H[-i,-j])/(sqrt(1+qcf.delta(j,0))*sqrt(1+qcf.delta(i,0)))
print(H)
print(eH)
ew, ev = linalg.eig(eH)
