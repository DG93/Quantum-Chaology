# -*- coding: utf-8 -*-
"""
Created on Tue Nov 24 13:57:21 2015

@author: mbcx2dg2
"""
import matplotlib.pyplot as plt
import numpy as np
import QRTRstad_level_rep as QS
import time
from itertools import product



s_state = 6
no_aspects = 10
init_states = list(range(0, s_state))


r=19 
c=[]
ratio=[]
# measure process time
t0 = time.clock()
for i in range(1,no_aspects):#r+1):
    c.append(r+i*2)
    ratio.append((c[i-1]-1)/(r-1))

wvfns=[]
val=[]
for i in range(0,len(c)):
    z, E = QS.main(r,c[i],s_state)
    wvfns.append(z)
    val.append(E)

def multi_for(iterables):
    if not iterables:
        yield ()
    else:
        for item in iterables[0]:
            for rest_tuple in multi_for(iterables[1:]):
                yield (item,) + rest_tuple

def iterables(s_state):
    ranges = [s_state]*s_state
    return list(map(range, ranges))


def anydup(thelist):
  seen = set()
  for x in thelist:
    if x in seen: return True
    seen.add(x)
  return False
    
def NextStates(ddots, s_state):
    flag=0
    ddots=np.array(ddots)
    P_tot=0
    for j in multi_for(iterables(s_state)):
        if anydup(j) == False:
            print(j)
            for i in range(0,s_state):
                P_tot = P_tot+ddots[i][j[i]]
            if P_tot > flag:
                flag = P_tot
                final_states = j
            P_tot=0

    # print('ddots:')
    # print(ddots)   
    print(final_states)  
    return final_states



# def NextStates(ddots, s_state):
#     flag=0
#     ddots=np.array(ddots)
#     for k in range(0,s_state):
#         for l in range(0,s_state):
#             if l!=k:
#                 for m in range(0,s_state):
#                     if(m!=l)and(m!=k):
#                         P_tot = ddots[0][k]+ddots[1][l]+ddots[2][m]
#                         if P_tot > flag:
#                             flag = P_tot
#                             final_states = [k,l,m]
    
#     # print('ddots:')
#     # print(ddots)   
#     print(final_states)  
#     return final_states


fig = plt.figure(figsize=(15,10))
init_states = list(range(0, s_state))
Eval=[]
Eval_t=[]
for i in init_states:
        Eval_t.append(val[0][i])
Eval.append(Eval_t)
ddots=[]
Eval_t=[]
dots=[]
ddots=[]
all_states=[]
all_states.append(init_states)
for j in range(1,len(c)):   # j is index of aspect_ratio
    
    for init_state in init_states:
        for i in range(0,s_state):  # i labels possible final states
            dots.append(np.dot(wvfns[j-1][init_state],wvfns[j][i]))
        ddots.append(dots)
        dots=[]

    
    fin_states = NextStates(ddots,s_state)
    all_states.append(init_states)
    init_states = fin_states
    for i in fin_states:
        Eval_t.append(val[j][i])

    Eval.append(Eval_t)
    Eval_t=[]


    print('ddots:')
    print(ddots)    
    #print(ratio)
    print('Eval:')
    print(Eval)
    ddots=[]             
print(all_states)                                                
Eval_tt=[]
for i in range(0,s_state):
    for j in range(0,len(c)):
        Eval_tt.append(Eval[j][i])
    plt.plot(ratio, Eval_tt, label='Level %i' %i)
    Eval_tt=[]
    
plt.title('Level Repulsion', fontsize=30)
plt.xlabel('Aspect Ratio',fontsize=20)
plt.ylabel('Energy',fontsize=20)
plt.xlim(min(ratio),max(ratio))
plt.legend()                
                
comp_time = (time.clock()-t0)/60.0
print("TIME TO COMPUTE: %f mins" %comp_time)    
plt.show()
fig.savefig('Level_rep_%i_%1.2f.png' %(s_state, max(ratio)))
